# 트랜잭션
>트랜잭션은 DB에서 하나의 논리적 기능을 수행하기 위한 연산 단위를 말한다<br>
>즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다

A->B로 돈을 보내려고 한다 이런 상황에서
- A의 통장 잔고를 조회하여, 보내려는 금액 이상이 존재하는지 확인한다
- A의 통장 잔고에서 보내려는 금액만큼 값을 뺀다
- B의 통장 잔고에는 받는 금액만큼을 더한다
위 세가지 과정 중 연결 불안정 등의 문제가 발생한다면?
- A의 통장에서 돈이 빠져나가고, B의 통장으로 입금되지 않는다
- A의 잔고를 조회하고 보내려는 금액만음을 빼려는 사이 A가 다른 곳에 돈을 쓴다. 그러면 남은 잔고는 보내려는 금액보다 적어지는데, 앞에서 확인할 때는 보내려는 금액 이상 있었으므로 통장 잔고에서 금액을 그대로 뺀다
트랜잭션은 위와 같은 경우가 발생하는 것을 방지하기 위해 존재하며, 트랜 잭션의 특징 4개를  ACID (Atomicity, Consistency, Isolation, Durability)라고 부른다

### 1) 원자성 (Atomicity)
- 트랜잭션 내의 내용들이 하나의 단위(atomic)로 묶여서, 전체가 수행되거나 전체가 수행되지 않아야 한다는 속성을 가리킨다 
- 위의 예시에서 A가 B에게 돈을 보내줄 때 일어나는 세 가지 연산이 모두 실행되거나, 모두 실행되지 않아야 하는 성질을 말한다
- 여기서 커밋과 롤백의 개념이 등장한다
- `commit` :
  - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  - 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다
- `rollback` :
  - 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 할 때 사용한다
  - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)을 말한다
- DBMS는 commit과 rollback을 통해 트랜잭션의 원자성을 보장해 준다 
```java
@Service
public Class MemberService {
    ...
    @Transactional
    public HashMap<String, String> updateClassMember(Map<String, Object> param) throws Exception {
        ...
    }
}
```
Spring 프레임워크에서는 Service 계층에서 `@Transactional`이라는 어노테이션을 통해 메소드 내의 로직의 원자성을 보장한다.
> 여기서 잠깐, @Transactional 어노테이선을 붙이지 않으면 어떤 일이 일어날까?<br>
> 1000개의 데이터를 for 문을 돌면서 insert를 한다고 가정해보자.<br>
> 200개가 들어갔는데 201번째에서 에러가 났다. 이때 이미 들어간 200개를 유지하는 경우도 있을수 있겠지만 유지하지 않는 경우도 있다. 즉 '1000개가 다 들어가거나 아니면 하나도 들어가지 않거나' 가 되어야하는 경우이다.<br>
> 이때 자바 if로 어떻게 할 수 있을까? 당장 머릿속에 드는 생각은 여태껏 반복해온 반복문의 인덱스를 구해서 다시 0부터 해당 인덱스까지의 데이터를 delete 해줘야 하는 불상사가 생긴다.<br>
>DB 트랜잭션에는 ACID 원칙이라고하는 4가지 원칙이 있는데 이중 A가 atomic(원자성)이다.<br>
> 1000개가 들어가는 메서드에 트랜잭션을 걸어놓으면 1000개가 다 들어가지 않았을 경우에 DB가 알아서 들어간 200개를 롤백시킨다!
### 2) 일관성 (Consistency)
- 허용된 방식으로만 데이터를 변경해야하는 것을 의미한다
- DB에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야한다
- 즉 **트랜잭션 작업이 시작되지 전에 데이터베이스 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 데이터 베이스 상태를 유지해아한다.**
### 3) 격리성(고립성) (Isolation)
- 둘 이상의 트랜잭션이 동시에 실행되고 있는 경우, 각각 다른 트랜잭션의 연산에 영향을 주어서는 안된다.
    - 각 트랜잭션의 수행은 독립적이어야 함을 의미한다.
- 위의 예시 중, A의 금액을 조회하고 A로부터 금액을 빼오는 사이에 다른 트랜잭션이 수행되어서 A의 잔고값이 변했다면, 격리성을 해치는 일이다.
- 작업이 수행되는 중 다른 작업이 끼어들지 못하도록 하는 개념이며, 격리 단계가 총 4가지 존재한다
  - Read Uncommitted
    - 아예 격리가 되지 않음.
    - Dirty Read, Non-repeatable Read, Phantom Read 현상이 발생할 수 있다.
  - Read Committed
    - 커밋된 데이터만 읽기 허용 
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기한다.
    - Non-Repeatable Read, Phantom Read 현상이 발생할 수 있다.   
  - Repeatable Read
    - 반복해서 데이터를 읽어도 일관성이 있다.
    - 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때 까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허
    - Phantom Read 현상이 발생할 수 있다.
  - Serializable
    - 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제하는 것을 불허하는것 뿐 아니라, 새로운 레코드를 삽입하는 것도 막아 완벽한 읽기 일관성을 보장
    - 일반적으로 레벨이 높아질 수록 트랜잭션 간 고립 정도가 높아지는 동시에 성능이 저하된다.
  - 위로 갈수록 동시성이 강해지지만 격리성은 약해지고, 아래로 갈수록 동시성은 약해지고 격리성은 강해진다
### 격리 수준에 따라 발생하는 현상
#### Phantom read, 팬텀 리드
한 트랜잭션 내에서 **동일한 쿼리**를 보냈을 때 해당 조회 결과가 다른 경우를 말한다. (처음에 읽 었을 때 없던 유령이 생겼다)

#### non-repeatable read, 반복 가능하지 않은 조회
- 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에서 다른 트랜잭션이 수정 or 삭제해서 둘의 결과가 다르게 나타나는 현상이 발생 할 수 있다.
- 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
예를 들어 
1. 현재 A의 잔고가 100원일 때, 
2. 은행원1이 A의 잔고를 조회했는데, 
3. 그 이후 은행원2가 그 값을 1원으로 변경해서 커밋하면 
4. 은행원1은 100원이 아닌 1원을 읽게됩니다.

#### Dirty read, 더티 리드 
한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 `커밋되지 않은` 행의 데이터를 읽을 수 있을 때 발생합니다. 

예를 들어
1. 은행원1이 A의 잔고를 100원에서 1원으로 수정했는데 아직 커밋을 하지 않았을 때,
2. 은행원2는 A의 잔고를 1원 이라고 조회함

### 격리 수준
|         수준         |내용|단점|
|:------------------:|-----|------|
|    SERIALIZABLE    |순차적으로 진행시키는 것|교착 상태(데드락)가 일어날 확률이 높음|
|  REPEATABLE_READ   |행 수정은 불가능하지만 행 추가는 가능|이후에 추가된 행이 발견될 수 있음|
|  READ_COMMITTED  |커밋하지 않은 정보는 읽을 수 없음|동시에 접근 가능하여 다른 내용이 발견될 수 있음|
|  READ_UNCOMMITTED  |커밋되기 이전에 다른 트랜잭션에 노출됨|무결성이 유지되지 않을 수 있음|
### 4) 지속성 (Durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다
- DB에 시스템 장애가 발생해도, DBMS는 자체적으로 복구하는 능력을 가지고 있으며, 이를 통해 지속성을 만족한다.